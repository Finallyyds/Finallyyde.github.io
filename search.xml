<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JVM运行时数据区</title>
    <url>/2023/02/13/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/</url>
    <content><![CDATA[<h3 id="JVM是什么"><a href="#JVM是什么" class="headerlink" title="JVM是什么"></a>JVM是什么</h3><p><strong>定义:</strong><br>JVM是Java Virtual Machine（Java虚拟机）的缩写，是一台执行Java字节码的虚拟计算机，它拥有独立的运行机制。<br>可以将JVM理解为是一个运行字节码的平台。<br>作用：</p>
<ul>
<li>提供Java的运行环境</li>
<li>加载代码、验证代码、执行代码</li>
<li>垃圾回收<h3 id="JVM整个运行原理图"><a href="#JVM整个运行原理图" class="headerlink" title="JVM整个运行原理图"></a>JVM整个运行原理图</h3><img src="https://img-blog.csdnimg.cn/3e342c3b3f64482ca9986f8ba5b66f66.png" alt="在这里插入图片描述"><br>元空间（JDK1.7,方法区、JDK1.6永久代）</li>
</ul>
<h3 id="JVM的内存结构划分"><a href="#JVM的内存结构划分" class="headerlink" title="JVM的内存结构划分"></a>JVM的内存结构划分</h3><p>加载进来的.class字节码文件、代码执行创建的对象、代码执行调用方法，方法中有变量等数据需要一个地方存放，所以JVM划分出了几个区域，用于存放这些信息；hotspot<br> <img src="https://img-blog.csdnimg.cn/c4beee94c63646dc80c73bc62ec03432.png" alt="在这里插入图片描述"><br>在JDK1.8之前，元空间就是原来的方法区（永久代）；</p>
<ul>
<li>堆、元空间（方法区）是线程共享的；</li>
<li>其他区域是线程私有的；</li>
</ul>
<h3 id="程序计数器-的特点及作用"><a href="#程序计数器-的特点及作用" class="headerlink" title="程序计数器 的特点及作用"></a>程序计数器 的特点及作用</h3><p>1、程序计数器是一块较小的内存空间，几乎可以忽略；<br>2、是当前线程所执行的字节码的行号指示器；<br>3、Java多线程执行时，每条线程都有一个独立的程序计数器，各条线程之间计数器互不影响；<br>4、该区域是“线程私有”的内存，每个线程独立存储；<br>5、该区域不存在OutOfMemoryError；<br>6、无GC回收；（随着线程结束而销毁）</p>
<h3 id="虚拟机栈的特点及作用"><a href="#虚拟机栈的特点及作用" class="headerlink" title="虚拟机栈的特点及作用"></a>虚拟机栈的特点及作用</h3><p>一个方法一个栈帧<br><img src="https://img-blog.csdnimg.cn/27da4967ab7b4e4f965bf7a31d72e809.png" alt="在这里插入图片描述"><br>1、线程私有；<br>2、方法执行会创建栈帧，存储局部变量表等信息；<br>3、方法执行入虚拟机栈，方法执行完出虚拟机栈；（先进后出）<br>4、栈深度大于虚拟机所允许StackOverflowError；<br>5、栈需扩展而无法申请空间OutOfMemoryError（比较少见）；hotspot虚拟机没有；<br>6、栈里面运行方法，存放方法的局部变量名，变量名所指向的值（常量值、对象值等）都存放到堆上的；<br>7、栈一般都不设置大小，栈所占的空间其实很小，可以通过<code>-Xss1M</code>进行设置，如果不设置默认为1M；<br>8、随线程而生，随线程而灭；<br>9、该区域不会有GC回收；</p>
<h3 id="Java堆的特点及作用"><a href="#Java堆的特点及作用" class="headerlink" title="Java堆的特点及作用"></a>Java堆的特点及作用</h3><p><img src="https://img-blog.csdnimg.cn/6370e794d10b4be091e69715376a1c90.png" alt="在这里插入图片描述"><br>1、线程共享的一块区域；<br>2、虚拟机启动时创建；<br>3、虚拟机所管理的内存中最大的一块区域；<br>4、存放所有实例对象或数组；<br>5、GC垃圾收集器的主要管理区域；<br>6、可分为新生代<strong>刚刚创建的对象</strong>、老年代；<br>7、新生代更细化可分为Eden、From Survivor、To Survivor，Eden:Survivor = 8:1:1<br>8、可通过<code>-Xmx</code>（设置堆的最大内存）、<code>-Xms</code> (设置堆的最小内存)调节堆大小；<br>9、无法再扩展java.lang.OutOfMemoryError: Java heap space<br>10、如果从分配内存的角度看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB），以提升对象分配时的效率；</p>
<h3 id="JVM什么情况下会发生堆内存溢出"><a href="#JVM什么情况下会发生堆内存溢出" class="headerlink" title="JVM什么情况下会发生堆内存溢出"></a>JVM什么情况下会发生堆内存溢出</h3><p>Java堆中用于储存对象，只要不断地创建对象，并且保持GC Roots到对象之间有可达路径<br>来避免垃圾回收机制清理这些对象，那么随着对象数量的增加，总容量达到最大堆的容量限制后就会产生内存溢出；<br>MAT工具分析xxx.hprof文件，排查溢出的原因；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Xms3072M 最小堆的大小</span><br><span class="line">-Xmx3072M 是最大堆的大小 </span><br><span class="line">-Xmn1536M 设置年轻代大小</span><br><span class="line">-Xss1M  设置每个线程的堆栈大小</span><br><span class="line">-XX:-UseCompressedClassPointers</span><br><span class="line">-XX:MetaspaceSize=256M</span><br><span class="line">-XX:MaxMetaspaceSize=256M </span><br><span class="line">-XX:SurvivorRatio=<span class="number">8</span></span><br><span class="line">-XX:MaxTenuringThreshold=<span class="number">5</span></span><br><span class="line">-XX:PretenureSizeThreshold=1M</span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line">-XX:+PrintGCDateStamps</span><br><span class="line">-Xloggc:d:/dev/gc.log</span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line">-XX:HeapDumpPath=d:/dev/heapdump.hprof</span><br></pre></td></tr></table></figure>




]]></content>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL面试题</title>
    <url>/2023/02/13/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h3 id="1-什么是索引？索引的优缺点？"><a href="#1-什么是索引？索引的优缺点？" class="headerlink" title="1.什么是索引？索引的优缺点？"></a>1.什么是索引？索引的优缺点？</h3><p>索引是一种<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&spm=1001.2101.3001.7020">数据结构</a>，是<strong>存储引擎用来快速找到数据的一种数据结构</strong>。</p>
<p>索引就是在磁盘上维护一个数据结构，这个数据结构一般是树，这里假设是二叉搜索树（其实默认索引以B+树的形式存在），以KV键值对的形式存储地址。</p>
<p><strong>索引的优缺点</strong></p>
<p><strong>优点:</strong></p>
<ul>
<li>最主要的优点，降低了数据库IO成本，提高了数据检索效率</li>
<li>通过唯一索引，保证数据唯一性（唯一约束也是通过添加唯一索引才保证了唯一性）</li>
<li>对于有依赖关系的表，可以加速表与表之间的连接</li>
<li>进行分组和排序查询时，可以减少查询中进行分组和排序的时间，降低了CPU消耗（索引中已经自动完成了排序和分组，所以直接查询降低消耗）</li>
</ul>
<p><strong>缺点:</strong></p>
<ul>
<li>创建和维护索引需要时间</li>
<li>索引占据磁盘空间（有时候索引可能比数据大…）</li>
<li>降低了表的更新速度(虽然提高了查询速度，但是在更新表时索引也需要更新…)</li>
</ul>
<h3 id="2-索引的数据结构？"><a href="#2-索引的数据结构？" class="headerlink" title="2.索引的数据结构？"></a>2.索引的数据结构？</h3><p>索引的数据结构和具体存储引擎的实现有关，MySQL 中常用的是 <strong>Hash</strong> 和 <strong>B+ 树</strong>索引。</p>
<ul>
<li><strong>Hash 索引</strong>底层就是 <a href="https://so.csdn.net/so/search?q=Hash&spm=1001.2101.3001.7020">Hash</a> 表，进行查询时调用 Hash 函数获取到相应的键值（对应地址），然后回表查询获得实际数据.</li>
<li><strong>B+ 树索引</strong>底层实现原理是多路平衡查找树，对于每一次的查询都是从根节点出发，查询到叶子节点方可以获得所查键值，最后查询判断是否需要回表查询.</li>
</ul>
<h3 id="3-Hash-和-B-树索引的区别？"><a href="#3-Hash-和-B-树索引的区别？" class="headerlink" title="3.Hash 和 B+ 树索引的区别？"></a>3.Hash 和 B+ 树索引的区别？</h3><p><strong>Hash</strong><br>1）Hash 进行等值查询更快，但无法进行范围查询。因为经过 Hash 函数建立索引之后，索引的顺序与原顺序无法保持一致，故不能支持范围查询。同理，也不支持使用索引进行排序。</p>
<p>2）Hash 不支持模糊查询以及多列索引的最左前缀匹配,因为 Hash 函数的值不可预测，如 AA 和 AB 的算出的值没有相关性。</p>
<p>3）Hash 任何时候都避免不了回表查询数据.</p>
<p>4）虽然在等值上查询效率高，但性能不稳定，因为当某个键值存在大量重复时，产生 Hash 碰撞，此时查询效率反而可能降低。</p>
<p><strong>B+ Tree</strong></p>
<p>1）B+ 树本质是一棵查找树，自然支持范围查询和排序。</p>
<p>2）在符合某些条件（聚簇索引、覆盖索引等）时候可以只通过索引完成查询，不需要回表。</p>
<p>3）查询效率比较稳定，因为每次查询都是从根节点到叶子节点，且为树的高度。</p>
<h3 id="4-B树和B-树的区别"><a href="#4-B树和B-树的区别" class="headerlink" title="4.B树和B+树的区别"></a>4.B树和B+树的区别</h3><p><strong>1）B树的每个结点都存储了key和data，B+树的data存储在叶子节点上，节点不存储data，这样一个节点就可以存储更多的key。可以使得树更矮，所以IO操作次数更少。<br>2）树的所有叶子结点仅仅一层构成一个有序链表，可以按照关键码排序的次序遍历全部记录由于数据顺序排列并且相连，所以便于区间查找和搜索。<br>而B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。</strong></p>
<p><strong>B+树</strong>（每一个节点相当于一页，每页大小大概为16kb，非叶子节点只存储索引）</p>
<ul>
<li>B+树有两种类型的节点：内部结点（也称索引结点）和叶子结点。内部节点就是非叶子节点，内部节点不存储数据，只存储索引，数据都存储在叶子节点。</li>
<li>内部结点中的key都按照从小到大的顺序排列，对于内部结点中的一个key，左树中的所有key都小于它，右子树中的key都大于等于它。叶子结点中的记录也按照key的大小排列。</li>
<li>每个叶子结点都存有相邻叶子结点的指针，叶子结点本身依关键字的大小自小而大顺序链接。</li>
<li>父节点存有右孩子的第一个元素的索引。</li>
</ul>
<p><img src="https://gitee.com/projiect/typora-images/raw/master/test/image-20220918163209816.png" alt="image-20220918163209816"></p>
<h3 id="5-事务的四大特征和隔离级别"><a href="#5-事务的四大特征和隔离级别" class="headerlink" title="5.事务的四大特征和隔离级别"></a>5.事务的四大特征和隔离级别</h3><p><strong>ACID:</strong></p>
<ul>
<li>A:原子性：整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执 行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</li>
<li>C:一致性：在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。</li>
<li>I:隔离性：指的是⼀个事务的修改在最终提交前，对其他事务是不可⻅的。</li>
<li>D:持久性：在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。</li>
</ul>
<p>隔离性有4个<strong>隔离级别</strong>，分别是：</p>
<ul>
<li>read uncommit 读未提交，可能会读到其他事务未提交的数据，也叫做脏读。</li>
<li>read commit 读已提交，两次读取结果不⼀致，叫做不可重复读。</li>
<li>repeatable read 可重复复读，这是mysql的默认级别，就是每次读取结果都⼀样，但是有可能产 ⽣幻读。</li>
<li>serializable 串⾏，⼀般是不会使⽤的，他会给每⼀⾏读取的数据加锁，会导致⼤量超时和锁竞争 的问题。</li>
</ul>
<p>脏读(Drity Read)：某个事务已更新⼀份数据，另⼀个事务在此时读取了同⼀份数据，由于某些原因， 前⼀个RollBack了操作，则后⼀个事务所读取的数据就会是不正确的。</p>
<p>不可重复读(Non-repeatable read):在⼀个事务的两次查询之中数据不⼀致，这可能是两次查询过程中 间插⼊了⼀个事务更新的原有的数据。</p>
<p>幻读(Phantom Read):在⼀个事务的两次查询中数据笔数不⼀致，例如有⼀个事务查询了⼏列(Row)数 据，⽽另⼀个事务却在此时插⼊了新的⼏列数据，先前的事务在接下来的查询中，就会发现有⼏列数据 是它先前所没有的。</p>
<h3 id="6-ACID是靠什么保证的？"><a href="#6-ACID是靠什么保证的？" class="headerlink" title="6.ACID是靠什么保证的？"></a>6.ACID是靠什么保证的？</h3><p>A:原子性–&gt;依靠undo log日志来保证，在日志中会记录需要回滚的日志信息，事务回滚时撤销以执行的sql语句。</p>
<p>C:一致性–&gt;由其他三⼤特性保证、程序代码要保证业务上的⼀致性</p>
<p>I:隔离性–&gt;通过MVCC来保证</p>
<p>D:持久性–&gt;由内存+reado log来保证，mysql修改数据同时在内存和redo log记录这次操作，宕机的时候可 以从redo log恢复。</p>
<blockquote>
<blockquote>
<p>InnoDB redo log 写盘，InnoDB 事务进⼊ prepare 状态。 如果前⾯ prepare 成功，binlog 写盘，再继续将事务⽇志持久化到 binlog，如果持久化成功， 那么 InnoDB 事务则进⼊ commit 状态(在 redo log ⾥⾯写⼀个 commit 记录)</p>
</blockquote>
</blockquote>
<p>redolog的刷盘会在系统空闲时进⾏</p>
<h3 id="7-Innodb是如何实现事务的"><a href="#7-Innodb是如何实现事务的" class="headerlink" title="7.Innodb是如何实现事务的"></a>7.Innodb是如何实现事务的</h3><p>nnodb通过Buffer Pool，LogBuffer，Redo Log，Undo Log来实现事务，以⼀个update语句为例：</p>
<ol>
<li>Innodb在收到⼀个update语句后，会先根据条件找到数据所在的⻚，并将该⻚缓存在Buffer Pool中 </li>
<li> 执⾏update语句，修改Buffer Pool中的数据，也就是内存中的数据 </li>
<li>针对update语句⽣成⼀个RedoLog对象，并存⼊LogBuffer中 </li>
<li> 针对update语句⽣成undolog⽇志，⽤于事务回滚 </li>
<li> 如果事务提交，那么则把RedoLog对象进⾏持久化，后续还有其他机制将Buffer Pool中所修改的数 据⻚持久化到磁盘中 </li>
<li>如果事务回滚，则利⽤undolog⽇志进⾏回滚</li>
</ol>
<h3 id="8-Mysql聚簇和⾮聚簇索引的区别"><a href="#8-Mysql聚簇和⾮聚簇索引的区别" class="headerlink" title="8.Mysql聚簇和⾮聚簇索引的区别"></a>8.Mysql聚簇和⾮聚簇索引的区别</h3><p>都是B+树的数据结构</p>
<ul>
<li>聚簇索引：将数据存储与索引放到了⼀块、并且是按照⼀定的顺序组织的，找到索引也就找到了数据，数据的物理存放顺序与索引顺序是⼀致的，即：只要索引是相邻的，那么对应的数据⼀定也是 相邻地存放在磁盘上的</li>
<li>⾮聚簇索引：叶⼦节点不存储数据、存储的是数据⾏地址，也就是说根据索引查找到数据⾏的位置 再取磁盘查找数据，这个就有点类似⼀本书的⽬录，⽐如我们要找第三章第⼀节，那我们先在这个 ⽬录⾥⾯找，找到对应的⻚码后再去对应的⻚码看⽂章。</li>
</ul>
<p>优势：</p>
<p>1、查询通过聚簇索引可以直接获取数据，相⽐⾮聚簇索引需要第⼆次查询（⾮覆盖索引的情况 下）效率要⾼ </p>
<p>2、聚簇索引对于范围查询的效率很⾼，因为其数据是按照⼤⼩排列的 </p>
<p>3、聚簇索引适合⽤在排序的场合，⾮聚簇索引不适合</p>
<p>劣势： </p>
<p>1、维护索引很昂贵，特别是插⼊新⾏或者主键被更新导⾄要分⻚(page split)的时候。建议在⼤量插⼊ 新⾏后，选在负载较低的时间段，通过OPTIMIZE TABLE优化表，因为必须被移动的⾏数据可能造成碎 ⽚。使⽤独享表空间可以弱化碎⽚ </p>
<p>2、表因为使⽤UUId（随机ID）作为主键，使数据存储稀疏，这就会出现聚簇索引有可能有⽐全表扫⾯ 更慢，所以建议使⽤int的auto_increment作为主键 </p>
<p>3、如果主键⽐较⼤的话，那辅助索引将会变的更⼤，因为辅助索引的叶⼦存储的是主键值；过⻓的主 键值，会导致⾮叶⼦节点占⽤占⽤更多的物理空间</p>
<h3 id="9-MySQL慢查询该如何优化？"><a href="#9-MySQL慢查询该如何优化？" class="headerlink" title="9.MySQL慢查询该如何优化？"></a>9.MySQL慢查询该如何优化？</h3><p>1.检查是否走了索引，如果没有则优化SQL利用索引</p>
<p>2.检查所利用的索引是否是最优索引</p>
<p>3.检查所查字段是否是必须的，是否查询了过多自段，查出来多余冗余</p>
<p>4.检查表中数据是否过多，是不是该进行分组</p>
<p>5.检查数据库实例所在的机器性能配置，是否太低，是否可以增加资源</p>
<h3 id="10-MySQL锁有哪些？"><a href="#10-MySQL锁有哪些？" class="headerlink" title="10.MySQL锁有哪些？"></a>10.MySQL锁有哪些？</h3><p>按锁的粒度：</p>
<p>1.行锁：锁某一行数据，粒度最细，并发度高</p>
<p>2.表锁：锁某一张表的数据，粒度最大，并发度低</p>
<p>3.间隙锁：锁某银行区间</p>
<p>还可以分为：</p>
<p>共享锁：也就是读锁，⼀个事务给某⾏数据加了读锁，其他事务也可以读，但是不能写</p>
<p>排它锁：也就是写锁，⼀个事务给某⾏数据加了写锁，其他事务不能读，也不能写</p>
<p>还可以分为： </p>
<ol>
<li>乐观锁：并不会真正的去锁某⾏记录，⽽是通过⼀个版本号来实现的 </li>
<li>悲观锁：上⾯所的⾏锁、表锁等都是悲观锁</li>
</ol>
<h3 id="11-Mysql主从同步原理"><a href="#11-Mysql主从同步原理" class="headerlink" title="11.Mysql主从同步原理"></a>11.Mysql主从同步原理</h3><p>主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。</p>
<p>binlog日志：<br>它是mysql用来记录db改变的日志，<br>比如某条数据的值从0改为1 (DML语句)<br>比如某张表被删除了 (DDL语句)</p>
<p><strong>原理</strong></p>
<p>（1）主从同步设置好之后（进行相关的诸如ip，端口，服务id，等操作设置后）<br>（2）相关变动会写入到binlog中<br>（3）maser会启动一个线程：binlog dumplog 线程，这个线程会通知从机，当前存在SQL变更，并将binlog的变动发送到从机上<br>（4）从机收到请求后，会启动线程：i/o线程 ，该线程会将收到的binlog日志加载到中继日志delay log中<br>（5）从机中的另外一个线程：SQL 线程会读取relay日志中的信息，刷新到从机中</p>
<p><strong>全同步复制</strong></p>
<p>主库写⼊binlog后强制同步⽇志到从库，所有的从库都执⾏完成后才返回给客户端，但是很显然这个⽅ 式的话性能会受到严重影响。</p>
<p><strong>半同步复制</strong></p>
<p>和全同步不同的是，半同步复制的逻辑是这样，从库写⼊⽇志成功后返回ACK确认给主库，主库收到⾄ 少⼀个从库的确认就认为写操作完成。</p>
<h3 id="12-简述MyISAM和InnoDB的区别"><a href="#12-简述MyISAM和InnoDB的区别" class="headerlink" title="12.简述MyISAM和InnoDB的区别"></a>12.简述MyISAM和InnoDB的区别</h3><p><strong>MyISAM</strong></p>
<ul>
<li><p>不⽀持事务，但是每次查询都是原⼦的；</p>
</li>
<li><p>支持表级锁，即每次操作是对整个表加锁；</p>
</li>
<li><p>存储表的总⾏数；</p>
</li>
<li><p>⼀个MYISAM表有三个⽂件：索引⽂件、表结构⽂件、数据⽂件；</p>
</li>
<li><p>采⽤⾮聚集索引，索引⽂件的数据域存储指向数据⽂件的指针。辅索引与主索引基本⼀致，但是辅 索引不⽤保证唯⼀性。</p>
</li>
</ul>
<p><strong>InnoDB</strong></p>
<ul>
<li>⽀持ACID的事务，⽀持事务的四种隔离级别；</li>
<li>⽀持⾏级锁及外键约束：因此可以⽀持写并发；</li>
<li>不存储总⾏数；</li>
<li>⼀个InnoDb引擎存储在⼀个⽂件空间（共享表空间，表⼤⼩不受操作系统控制，⼀个表可能分布在 多个⽂件⾥），也有可能为多个（设置为独⽴表空，表⼤⼩受操作系统⽂件⼤⼩限制，⼀般为 2G），受操作系统⽂件⼤⼩的限制；</li>
<li>主键索引采⽤聚集索引（索引的数据域存储数据⽂件本身）</li>
</ul>
<h3 id="13-什么是MVCC？"><a href="#13-什么是MVCC？" class="headerlink" title="13.什么是MVCC？"></a>13.什么是MVCC？</h3><p><strong>MVCC</strong>(Multi Version Concurrency Control的简称)，代表<strong>多版本并发控制</strong>。</p>
<p>MVCC最大的优势：<strong>读不加锁，读写不冲突</strong>。读写不冲突是非常重要的，极大的增加了系统的并发性能。<strong>MVCC机制也是乐观锁的一种体现。</strong></p>
<p>MVCC只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下⼯作。其他两个隔离级别够和 MVCC不兼容, 因为 READ UNCOMMITTED 总是读取最新的数据⾏, ⽽不是符合当前事务版本的数据 ⾏。⽽ SERIALIZABLE 则会对所有读取的⾏都加锁。</p>
<p>聚簇索引记录中有两个必要的隐藏列：</p>
<p> trx_id：⽤来存储每次对某条聚簇索引记录进⾏修改的时候的事务id。 </p>
<p>roll_pointer：每次对哪条聚簇索引记录有修改的时候，都会把⽼版本写⼊undo⽇志中。这个 roll_pointer就是存了⼀个指针，它指向这条聚簇索引记录的上⼀个版本的位置，通过它来获得上⼀个版 本的记录信息。(注意插⼊操作的undo⽇志没有这个属性，因为它没有⽼版本)</p>
<p>开始事务时创建readview，readView维护当前活动的事务id，即未提交的事务id，排序⽣成⼀个数组</p>
<p>访问数据时，获取数据中的事务id（获取的是事务id最⼤的记录），对⽐readview：</p>
<p>判断该事务的id在readview的左边，表示可以访问（左边意味着该事务已经提交）</p>
<p>如果在readview的右边（比readview要大），不可以访问，或者在readview中，获取roll_pointer，取 上⼀版本重新对⽐（在右边意味着，该事务在readview⽣成之后出现，在readview中意味着该事务还未 提交）</p>
<p>已提交读隔离级别下的事务在每次查询的开始都会⽣成⼀个独⽴的ReadView,⽽可重复读隔离级别则在 第⼀次读的时候⽣成⼀个ReadView，之后的读都复⽤之前的ReadView。</p>
<p>这就是Mysql的MVCC,通过版本链，实现多版本，可并发读-写，写-读。通过ReadView⽣成策略的不 同实现不同的隔离级别。</p>
]]></content>
      <tags>
        <tag>面试</tag>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程基础</title>
    <url>/2023/02/13/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h3 id="1-并发、并⾏、串⾏之间的区别"><a href="#1-并发、并⾏、串⾏之间的区别" class="headerlink" title="1.并发、并⾏、串⾏之间的区别"></a>1.并发、并⾏、串⾏之间的区别</h3><ol>
<li>串⾏在时间上不可能发⽣重叠，前⼀个任务没搞定，下⼀个任务就只能等着 </li>
<li> 并⾏在时间上是重叠的，两个任务在同⼀时刻互不⼲扰的同时执⾏。 </li>
<li>并发允许两个任务彼此⼲扰。统⼀时间点、只有⼀个任务运⾏，交替执⾏</li>
</ol>
<h3 id="2-并发的三⼤特性-有序性-，原子性，可见性"><a href="#2-并发的三⼤特性-有序性-，原子性，可见性" class="headerlink" title="2.并发的三⼤特性:有序性 ，原子性，可见性"></a>2.并发的三⼤特性:有序性 ，原子性，可见性</h3><p>原子性：一个或多个操作，要么全部执行且在执行过程中不被任何因素打断，要么全部不执行。 关键字：synchronized</p>
<p>可见性：当一个线程修改了共享变量的值，其他线程能够看到修改的值。关键字：volatile、synchronized、final</p>
<p>有序性：即程序执行的顺序按照代码的先后顺序执行。关键字：volatile、synchronized</p>
<p>记住这三句话：指令重排导致了有序性；线程切换导致了原子性；缓存导致了可见性 。</p>
<h3 id="3-Java死锁如何避免？"><a href="#3-Java死锁如何避免？" class="headerlink" title="3.Java死锁如何避免？"></a>3.Java死锁如何避免？</h3><p>造成死锁的⼏个原因： </p>
<ol>
<li>⼀个资源每次只能被⼀个线程使⽤ </li>
<li>⼀个线程在阻塞等待某个资源时，不释放已占有资源 </li>
<li>⼀个线程已经获得的资源，在未使⽤完之前，不能被强⾏剥夺 </li>
<li>若⼲线程形成头尾相接的循环等待资源关系</li>
</ol>
<p>这是造成死锁必须要达到的4个条件，如果要避免死锁，只需要不满⾜其中某⼀个条件即可。⽽其中前3 个条件是作为锁要符合的条件，所以要避免死锁就需要打破第4个条件，不出现循环等待锁的关系。</p>
<p>在开发过程中： </p>
<ol>
<li>要注意加锁顺序，保证每个线程按同样的顺序进⾏加锁 </li>
<li>要注意加锁时限，可以针对所设置⼀个超时时间 </li>
<li>要注意死锁检查，这是⼀种预防机制，确保在第⼀时间发现死锁并进⾏解决</li>
</ol>
<h3 id="4-如何理解volatile关键字"><a href="#4-如何理解volatile关键字" class="headerlink" title="4.如何理解volatile关键字"></a>4.如何理解volatile关键字</h3><p>保证被volatile修饰的共享变量对所有线程总是可⻅的，也就是当⼀个线程修改了⼀个被volatile修饰共 享变量的值，新值总是可以被其他线程⽴即得知。</p>
<p>禁⽌指令重排序优化</p>
<h3 id="5-为什么⽤线程池？解释下线程池参数？"><a href="#5-为什么⽤线程池？解释下线程池参数？" class="headerlink" title="5.为什么⽤线程池？解释下线程池参数？"></a>5.为什么⽤线程池？解释下线程池参数？</h3><p>1、降低资源消耗；提⾼线程利⽤率，降低创建和销毁线程的消耗。</p>
<p>2、提⾼响应速度；任务来了，直接有线程可⽤可执⾏，⽽不是先创建线程，再执⾏。</p>
<p>3、提⾼线程的可管理性；线程是稀缺资源，使⽤线程池可以统⼀分配调优监控。</p>
<ul>
<li>corePoolSize 代表核⼼线程数，也就是正常情况下创建⼯作的线程数，这些线程创建后并不 会消除，⽽是⼀种常驻线程</li>
<li>maxinumPoolSize 代表的是最⼤线程数，它与核⼼线程数相对应，表示最⼤允许被创建的线程 数，⽐如当前任务较多，将核⼼线程数都⽤完了，还⽆法满⾜需求时，此时就会创建新的线程，但 是线程池内线程总数不会超过最⼤线程数</li>
<li>keepAliveTime 、 unit 表示超出核⼼线程数之外的线程的空闲存活时间，也就是核⼼线程 不会消除，但是超出核⼼线程数的部分线程如果空闲⼀定的时间则会被消除,我们可以通过 setKeepAliveTime 来设置空闲时间</li>
<li>workQueue ⽤来存放待执⾏的任务，假设我们现在核⼼线程都已被使⽤，还有任务进来则全部 放⼊队列，直到整个队列被放满但任务还再持续进⼊则会开始创建新的线程</li>
<li>ThreadFactory 实际上是⼀个线程⼯⼚，⽤来⽣产线程执⾏任务。我们可以选择使⽤默认的创 建⼯⼚，产⽣的线程都在同⼀个组内，拥有相同的优先级，且都不是守护线程。当然我们也可以选 择⾃定义线程⼯⼚，⼀般我们会根据业务来制定不同的线程⼯⼚</li>
<li>Handler 任务拒绝策略，有两种情况，第⼀种是当我们调⽤ shutdown 等⽅法关闭线程池 后，这时候即使线程池内部还有没执⾏完的任务正在执⾏，但是由于线程池已经关闭，我们再继续 想线程池提交任务就会遭到拒绝。另⼀种情况就是当达到最⼤线程数，线程池已经没有能⼒继续处 理新提交的任务时，这是也就拒绝</li>
</ul>
<h3 id="6-线程池的底层⼯作原理"><a href="#6-线程池的底层⼯作原理" class="headerlink" title="6.线程池的底层⼯作原理"></a>6.线程池的底层⼯作原理</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/37c1b8b7e534f1c4cd3f5c0550e9ab9e.png" alt="img"></p>
<ol>
<li>如果此时线程池中的数量小于corePoolSize，即使线程池中的线程都处于空闲状态，也要创建新的线程来处理被添加的任务。</li>
<li>如果此时线程池中的数量等于corePoolSize，但是缓冲队列workQueue未满，那么任务被放入缓冲队列。</li>
<li>如果此时线程池中的数量大于等于corePoolSize，缓冲队列workQueue满，并且线程池中的数量小于maximumPoolSize，建新的线程来处理被添加的任务。</li>
<li>如果此时线程池中的数量大于corePoolSize，缓冲队列workQueue满，并且线程池中的数量等于maximumPoolSize，那么通过 handler所指定的策略来处理此任务。</li>
<li>当线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止。这样，线程池可以动态的调整池中的线程数。</li>
</ol>
<p>总结即：处理任务判断的优先级为 核心线程corePoolSize、任务队列workQueue、最大线程maximumPoolSize，如果三者都满了，使用handler处理被拒绝的任务。</p>
<h3 id="CAS：CAS是一种乐观锁"><a href="#CAS：CAS是一种乐观锁" class="headerlink" title="CAS：CAS是一种乐观锁"></a>CAS：CAS是一种乐观锁</h3><p><strong>CAS缺点？</strong></p>
<p>1、循环时间开销大（如果CAS失败，会一直尝试）</p>
<p>２、只能保证一个共享变量的原子操作。（对多个共享变量操作时，循环CAS无法保证操作的原子性，只能用加锁来保证）</p>
<p>3、存在ABA问题</p>
<p><strong>原子类AtomicInteger类ABA问题及解决方案</strong></p>
<p>1、ABA问题是怎么产生的？</p>
<p>当第一个线程执行CAS(V,E,U)操作，在获取到当前变量V，准备修改为新的值U之前。另外两个线程已经连续修改了两次变量V的值，使得该值又恢复为旧的值，这样我们就无法正确判断这个变量是否已经被修改过</p>
<p>2、ABA问题的解决方案：</p>
<p>使用版本号的方式解决ABA问题.</p>
<p>AtomicStampedReference：是一个带有<strong>时间戳</strong>的对象引用，在每次修改后，不仅会设置新的值，还会记录修改的时间</p>
<p>AtomicMarkableReference：维护的是一个Boolean值的标识，这种方式并不能完全防止ABA问题的发生，只能减少ABA发生的概率</p>
<h3 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h3><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低。每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），如果失败则要重复读-比较-写的操作。</p>
<p>java中的乐观锁基本都是通过CAS操作实现的，<strong>CAS是一种更新的原子操作，比较当前值跟传入值是否一样，一样则更新，否则失败。</strong></p>
<h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a><a href="https://so.csdn.net/so/search?q=%E6%82%B2%E8%A7%82%E9%94%81&spm=1001.2101.3001.7020">悲观锁</a></h4><p>悲观锁是就是悲观思想，即认为写多，遇到并发写的可能性高。每次去拿数据的时候都认为别人会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会阻塞（block）直到拿到锁。</p>
<p>java中的悲观锁就是Synchronize、AQS框架下的锁则是先尝试CAS乐观锁去获取锁，<strong>获取不到才会转换为悲观锁</strong>，如：ReentrantLock。</p>
<h3 id="锁的状态无锁、偏向锁、轻量级锁、重量级锁"><a href="#锁的状态无锁、偏向锁、轻量级锁、重量级锁" class="headerlink" title="锁的状态无锁、偏向锁、轻量级锁、重量级锁"></a>锁的状态无锁、偏向锁、轻量级锁、重量级锁</h3><p><img src="https://img-blog.csdnimg.cn/20200603161323889.png" alt="在这里插入图片描述"></p>
<ol>
<li>偏向锁：在锁对象的对象头中记录⼀下当前获取到该锁的线程ID，该线程下次如果⼜来获取该锁就 可以直接获取到了 </li>
<li> 轻量级锁：由偏向锁升级⽽来，当⼀个线程获取到锁后，此时这把锁是偏向锁，此时如果有第⼆个 线程来竞争锁，偏向锁就会升级为轻量级锁，之所以叫轻量级锁，是为了和重量级锁区分开来，轻 量级锁底层是通过⾃旋来实现的，并不会阻塞线程 </li>
<li> 如果⾃旋次数过多仍然没有获取到锁，则会升级为重量级锁，重量级锁会导致线程阻塞 </li>
<li> ⾃旋锁：⾃旋锁就是线程在获取锁的过程中，不会去阻塞线程，也就⽆所谓唤醒线程，阻塞和唤醒 这两个步骤都是需要操作系统去进⾏的，⽐较消耗时间，⾃旋锁是线程通过CAS获取预期的⼀个标 记，如果没有获取到，则继续循环获取，如果获取到了则表示获取到了锁，这个过程线程⼀直在运 ⾏中，相对⽽⾔没有使⽤太多的操作系统资源，⽐较轻量。</li>
</ol>
<p>锁的升级的目的：锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。</p>
<h3 id="sleep-、wait-、join-、yield-之间的的区别"><a href="#sleep-、wait-、join-、yield-之间的的区别" class="headerlink" title="sleep()、wait()、join()、yield()之间的的区别"></a>sleep()、wait()、join()、yield()之间的的区别</h3><p>锁池：所有需要竞争同步锁的线程都会放在锁池当中，⽐如当前对象的锁已经被其中⼀个线程得到，则 其他线程需要在这个锁池进⾏等待，当前⾯的线程释放同步锁后锁池中的线程去竞争同步锁，当某个线 程得到后会进⼊就绪队列进⾏等待cpu资源分配。</p>
<p>等待池：当我们调⽤wait（）⽅法后，线程会放到等待池当中，等待池的线程是不会去竞争同步锁。只 有调⽤了notify（）或notifyAll()后等待池的线程才会开始去竞争锁，notify（）是随机从等待池选出⼀ 个线程放到锁池，⽽notifyAll()是将等待池的所有线程放到锁池当中</p>
<ol>
<li><p>sleep 是 Thread 类的静态本地⽅法，wait 则是 Object 类的本地⽅法。</p>
</li>
<li><p> sleep⽅法不会释放lock，但是wait会释放，⽽且会加⼊到等待队列中。</p>
</li>
<li><p>  sleep⽅法不依赖于同步器synchronized，但是wait需要依赖synchronized关键字</p>
</li>
<li><p>  sleep不需要被唤醒（休眠之后推出阻塞），但是wait需要（不指定时间需要被别⼈中断）。</p>
</li>
<li><p>  sleep ⼀般⽤于当前线程休眠，或者轮循暂停操作，wait 则多⽤于多线程之间的通信。 </p>
</li>
<li><p>sleep 会让出 CPU 执⾏时间且强制上下⽂切换，⽽ wait 则不⼀定，wait 后可能还是有机会重新竞 争到锁继续执⾏的。 sleep()、wait()、join()、yield()之间的的区别</p>
</li>
<li><p>yield（）执⾏后线程直接进⼊就绪状态，⻢上释放了cpu的执⾏权，但是依然保留了cpu的执⾏资 格，所以有可能cpu下次进⾏线程调度还会让这个线程获取到执⾏权继续执⾏ </p>
</li>
<li><p>join（）执⾏后线程进⼊阻塞状态，例如在线程B中调⽤线程A的join（），那线程B会进⼊到阻塞队 列，直到线程A结束或中断线程</p>
</li>
</ol>
<h3 id="Thread和Runable的区别"><a href="#Thread和Runable的区别" class="headerlink" title="Thread和Runable的区别"></a>Thread和Runable的区别</h3><p>Thread和Runnable的实质是继承关系，没有可⽐性。⽆论使⽤Runnable还是Thread，都会new Thread，然后执⾏run⽅法。⽤法上，如果有复杂的线程操作需求，那就选择继承Thread，如果只是简 单的执⾏⼀个任务，那就实现runnable。</p>
<h3 id="ThreadLocal的底层原理"><a href="#ThreadLocal的底层原理" class="headerlink" title="ThreadLocal的底层原理"></a>ThreadLocal的底层原理</h3><ol>
<li>ThreadLocal是Java中所提供的线程本地存储机制，可以利⽤该机制将数据缓存在某个线程内部， 该线程可以在任意时刻、任意⽅法中获取缓存的数据 </li>
<li>ThreadLocal底层是通过ThreadLocalMap来实现的，每个Thread对象（注意不是ThreadLocal对 象）中都存在⼀个ThreadLocalMap，Map的key为ThreadLocal对象，Map的value为需要缓存的 值 </li>
<li> 如果在线程池中使⽤ThreadLocal会造成内存泄漏，因为当ThreadLocal对象使⽤完之后，应该要把 设置的key，value，也就是Entry对象进⾏回收，但线程池中的线程不会回收，⽽线程对象是通过强 引⽤指向ThreadLocalMap，ThreadLocalMap也是通过强引⽤指向Entry对象，线程不被回收， Entry对象也就不会被回收，从⽽出现内存泄漏，解决办法是，在使⽤了ThreadLocal对象之后，⼿ 动调⽤ThreadLocal的remove⽅法，⼿动清楚Entry对象 </li>
<li>ThreadLocal经典的应⽤场景就是连接管理（⼀个线程持有⼀个连接，该连接对象可以在不同的⽅ 法之间进⾏传递，线程之间不共享同⼀个连接）<br><img src="https://img-blog.csdnimg.cn/img_convert/b9fae83930e028eecf8a1a4dc2b19bd5.jpeg" alt="img"></li>
</ol>
<p><strong>使用场景</strong>:<br>1、在进行对象跨层传递的时候，使用ThreadLocal可以避免多次传递，打破层次间的约束。</p>
<p>2、线程间数据隔离<br>3、进行事务操作，用于存储线程事务信息。</p>
<h3 id="ThreadLocal内存泄露原因，如何避免"><a href="#ThreadLocal内存泄露原因，如何避免" class="headerlink" title="ThreadLocal内存泄露原因，如何避免"></a>ThreadLocal内存泄露原因，如何避免</h3><p>内存泄露为程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光，<br>不再会被使用的对象或者变量占用的内存不能被回收，就是内存泄露。</p>
<p><strong>强引用</strong>:使用最普遍的引用(new)，一个对象具有强引用，不会被垃圾回收器回收。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不回收这种对象。<br>如果想取消强引用和某个对象之间的关联，可以显式地将引用赋值为null，这样可以使JVM在合适的时间就会回收该对象。</p>
<p><strong>弱引用</strong>:JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。在java中，用java.lang.ref.WeakReference类来表示。可以在缓存中使用弱引用。</p>
<p>ThreadLocal正确的使用方法<br>每次使用完ThreadLocal都调用它的remove()方法清除数据</p>
<p>将ThreadLocal变量定义成private static，这样就一直存在ThreadLocal的强引用，也就能保证任何时候都能通过ThreadLocal的弱引用访问到Entry的value值，进而清除掉。</p>
<h3 id="ReentrantLock中的公平锁和⾮公平锁的底层实现"><a href="#ReentrantLock中的公平锁和⾮公平锁的底层实现" class="headerlink" title="ReentrantLock中的公平锁和⾮公平锁的底层实现"></a>ReentrantLock中的公平锁和⾮公平锁的底层实现</h3><p>⾸先不管是公平锁和⾮公平锁，它们的底层实现都会使⽤AQS来进⾏排队，</p>
<p>它们的区别在于：线程在使 ⽤lock()⽅法加锁时，</p>
<ul>
<li>如果是公平锁，会先检查AQS队列中是否存在线程在排队，如果有线程在排队， 则当前线程也进⾏排队，</li>
<li>如果是⾮公平锁，则不会去检查是否有线程在排队，⽽是直接竞争锁。</li>
</ul>
<p>不管是公平锁还是⾮公平锁，⼀旦没竞争到锁，都会进⾏排队，当锁释放时，都是唤醒排在最前⾯的线 程，所以⾮公平锁只是体现在了线程加锁阶段，⽽没有体现在线程被唤醒阶段。</p>
<p>另外，ReentrantLock是可重⼊锁，不管是公平锁还是⾮公平锁都是可重⼊的。</p>
<h3 id="CountDownLatch和Semaphore的区别和底层原理"><a href="#CountDownLatch和Semaphore的区别和底层原理" class="headerlink" title="CountDownLatch和Semaphore的区别和底层原理"></a>CountDownLatch和Semaphore的区别和底层原理</h3><p>CountDownLatch表示计数器，可以给CountDownLatch设置⼀个数字，⼀个线程调⽤ CountDownLatch的await()将会阻塞，其他线程可以调⽤CountDownLatch的countDown()⽅法来对 CountDownLatch中的数字减⼀，当数字被减成0后，所有await的线程都将被唤醒。</p>
<p>对应的底层原理就是，调⽤await()⽅法的线程会利⽤AQS排队，⼀旦数字被减为0，则会将AQS中 排队的线程依次唤醒。</p>
<p>Semaphore表示信号量，可以设置许可的个数，表示同时允许最多多少个线程使⽤该信号量，通 过acquire()来获取许可，如果没有许可可⽤则线程阻塞，并通过AQS来排队，可以通过release() ⽅法来释放许可，当某个线程释放了某个许可后，会从AQS中正在排队的第⼀个线程开始依次唤 醒，直到没有空闲许可。</p>
<h3 id="Sychronized和ReentrantLock的区别"><a href="#Sychronized和ReentrantLock的区别" class="headerlink" title="Sychronized和ReentrantLock的区别"></a>Sychronized和ReentrantLock的区别</h3><ol>
<li>sychronized是⼀个关键字，ReentrantLock是⼀个类 </li>
<li>sychronized会⾃动的加锁与释放锁，ReentrantLock需要程序员⼿动加锁与释放锁 </li>
<li>sychronized的底层是JVM层⾯的锁，ReentrantLock是API层⾯的锁 </li>
<li>sychronized是⾮公平锁，ReentrantLock可以选择公平锁或⾮公平锁 </li>
<li> sychronized锁的是对象，锁信息保存在对象头中，ReentrantLock通过代码中int类型的state标识 来标识锁的状态 </li>
<li> sychronized底层有⼀个锁升级的过程</li>
</ol>
<h3 id="一、JAVA如何开启线程-怎么保证线程安全"><a href="#一、JAVA如何开启线程-怎么保证线程安全" class="headerlink" title="一、JAVA如何开启线程?怎么保证线程安全?"></a>一、JAVA如何开启线程?怎么保证线程安全?</h3><p>进程和线程的区别：进程是操作系统进行资源的最小单元。线程是操作系统进行任务分配的最小单元，线程隶属于进程。</p>
<p>如何开启进程？1.继承Thread类，重写run方法。2.实现Runable接口，实现run方法。3.实现Callable接口，实现call方法。通过FuterTask创建一个线程。获取到线程的执行的返回值，4.通过线程池来开启线程。</p>
<p>怎么保证线程安全?加锁: 1、JMM提供的锁，也就是Synchronized关键字。2、JDK提供的各种锁Lock。</p>
<h3 id="二、Volatile和Synchronized有什么区别-Volatile能不能保证线程安全-DCL-Double-Check-Lock-单例为什么要加Volatile"><a href="#二、Volatile和Synchronized有什么区别-Volatile能不能保证线程安全-DCL-Double-Check-Lock-单例为什么要加Volatile" class="headerlink" title="二、Volatile和Synchronized有什么区别? Volatile能不能保证线程安全?DCL(Double Check Lock)单例为什么要加Volatile?"></a>二、Volatile和Synchronized有什么区别? Volatile能不能保证线程安全?DCL(Double Check Lock)单例为什么要加Volatile?</h3><p>1、Synchronized关键字，用来加锁。Volatile只是保持变量的线程可见性。通常适用于一个线程写，多个线程读的场景。</p>
<p>2、不能。Volatile关键字只能保证线程可见性，不能保证原子性。</p>
<p>3、Volatile防止指令重排。在DCL中，防止高并发情况下，指令重排造成的线程安全问题。</p>
<h3 id="三、JAVA线程锁机制是怎样的-偏向锁、轻量级锁、重量级锁有什么区别-锁机制是如何升级的"><a href="#三、JAVA线程锁机制是怎样的-偏向锁、轻量级锁、重量级锁有什么区别-锁机制是如何升级的" class="headerlink" title="三、JAVA线程锁机制是怎样的?偏向锁、轻量级锁、重量级锁有什么区别?锁机制是如何升级的?"></a>三、JAVA线程锁机制是怎样的?偏向锁、轻量级锁、重量级锁有什么区别?锁机制是如何升级的?</h3><p>1、JAVA的锁就是在对象的Markword中记录一个锁状态。无锁，偏向锁，轻量级锁，重量级锁对应不同的锁状态。</p>
<p><img src="https://img-blog.csdnimg.cn/86f95ead1ff74a7c8a50efe75b99dd28.png#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/49fbf3fd803144e0954d755b817f4eee.png#pic_center" alt="在这里插入图片描述"></p>
<p>2、JAVA的锁机制就是根据资源竞争的激烈程度不断进行锁升级的过程。|</p>
<p><img src="https://img-blog.csdnimg.cn/0e1df9cb799045198056f8906581f660.png#pic_center" alt="在这里插入图片描述"></p>
<h3 id="四、谈谈你对AQS的理解。AQS如何实现可重入锁"><a href="#四、谈谈你对AQS的理解。AQS如何实现可重入锁" class="headerlink" title="四、谈谈你对AQS的理解。AQS如何实现可重入锁?"></a>四、谈谈你对AQS的理解。AQS如何实现可重入锁?</h3><p>1.AQS是一个JAVA线程同步的框架，是JDK中很多锁工具的核心实现框架。</p>
<p>2.在AQS中，维护了一个信号量state和一个线程组成的双向队列链表，其中，这个线程队列，就是用来给线程排队的，而state就是一个红绿灯，用来控制线程队列的排队或者放行的。在不同的处境下有不同的意义。<br><img src="https://img-blog.csdnimg.cn/3f526200ca204dbc80c162b0af92ff49.png#pic_center" alt="在这里插入图片描述"></p>
<p>3.在可重入锁这个场景下，state就用来表示加锁的次数，0标识无锁，每加一次锁，state就加1，每释放锁，state就减一</p>
<h3 id="五、有A-B-C三个线程，如何保证三个线程同时执行-如何在并发情况下保证三个线程依次执行-如何保证三个线程有序交错进行"><a href="#五、有A-B-C三个线程，如何保证三个线程同时执行-如何在并发情况下保证三个线程依次执行-如何保证三个线程有序交错进行" class="headerlink" title="五、有A,B,C三个线程，如何保证三个线程同时执行?如何在并发情况下保证三个线程依次执行?如何保证三个线程有序交错进行?"></a>五、有A,B,C三个线程，如何保证三个线程同时执行?如何在并发情况下保证三个线程依次执行?如何保证三个线程有序交错进行?</h3><p>CountDownLatch, CvlicBarrier, Semaphore。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//保证三个线程同时执行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">int</span> size=<span class="number">3</span>;</span><br><span class="line">    ThreadSalfDemo threadSalfDemo=<span class="keyword">new</span> <span class="title class_">ThreadSalfDemo</span>();</span><br><span class="line">    CountDownLatch countDownLatch=<span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                countDownLatch.await();</span><br><span class="line">                System.out.println(System.currentTimeMillis());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">    countDownLatch.countDown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//利用volatile来保证线程之间的数据可见性</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> ticket=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    Thread t1=<span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (ticket==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;a&quot;</span>+i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                ticket=<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Thread t2=<span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (ticket==<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;b&quot;</span>+i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                ticket=<span class="number">3</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Thread t3=<span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (ticket==<span class="number">3</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;c&quot;</span>+i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                ticket=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t3.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="如果你提交任务时，线程池队列已满，这时会发生什么"><a href="#如果你提交任务时，线程池队列已满，这时会发生什么" class="headerlink" title="如果你提交任务时，线程池队列已满，这时会发生什么"></a>如果你提交任务时，线程池队列已满，这时会发生什么</h3><p>1.如果使用的无界队列，那么可以继续提交任务时没关系的<br>⒉.如果使用的有界队列，提交任务时，如果队列满了，如果核心线程数没有达到上限，那么则增加线程，如果线程数已经达到了最大值，则使用拒绝策略进行拒绝</p>
<h3 id="如何查看线程死锁"><a href="#如何查看线程死锁" class="headerlink" title="如何查看线程死锁"></a>如何查看线程死锁</h3><p>1.可以通过jstack命令来进行查看，jstack命令中会显示发生了死锁的线程<br>⒉.或者两个线程去操作数据库时，数据库发生了死锁，这是可以查询数据库的死锁情况</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、查询是否锁表</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">OPEN</span> TABLES <span class="keyword">where</span> In_use <span class="operator">&gt;</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">2</span>、查询进程</span><br><span class="line"><span class="keyword">show</span> processlist;<span class="operator">|</span></span><br><span class="line"><span class="number">3</span>、查看正在锁的事务</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> INFORMATION_SCHEMA.INNODB_LOCKs;</span><br><span class="line"><span class="number">4</span>、查看等待锁的事务</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> INFORMATION_SCHEMA.INNODB_LOCK_WAITS;</span><br></pre></td></tr></table></figure>

<h3 id="线程之间如何进行通讯的"><a href="#线程之间如何进行通讯的" class="headerlink" title="线程之间如何进行通讯的"></a>线程之间如何进行通讯的</h3><p>1.线程之间可以通过共享内存或基于网络来进行通信<br>⒉如果是通过共享内存来进行通信，则需要考虑并发问题，什么时候阻塞，什么时候唤醒</p>
<p>3.像Java中的wait()、notify()就是阻塞和唤醒<br>4.通过网络就比较简单了，通过网络连接将通信数据发送给对方，当然也要考虑到并发问题，处理方式就是加锁等方式</p>
<p>ABLES where In_use &gt; 0;<br>2、查询进程<br>show processlist;|<br>3、查看正在锁的事务<br>SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCKs;<br>4、查看等待锁的事务<br>SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 线程之间如何进行通讯的</span><br><span class="line"></span><br><span class="line">1.线程之间可以通过共享内存或基于网络来进行通信</span><br><span class="line">⒉如果是通过共享内存来进行通信，则需要考虑并发问题，什么时候阻塞，什么时候唤醒</span><br><span class="line"></span><br><span class="line">3.像Java中的wait()、notify()就是阻塞和唤醒</span><br><span class="line">4.通过网络就比较简单了，通过网络连接将通信数据发送给对方，当然也要考虑到并发问题，处理方式就是加锁等方式</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Java</tag>
        <tag>面试</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java设计模式</title>
    <url>/2023/02/13/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p><strong>设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。</strong></p>
<p><strong>使用设计模式的目的：为了代码可重用性、让代码更容易被他人理解、保证代码可靠性。 设计模式使代码编写真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。</strong></p>
</blockquote>
<p><strong>Java==设计模式==分为三大类</strong></p>
<ul>
<li><p><strong>创建型模式：对象实例化的模式，创建型模式用于解耦对象的实例化过程。</strong></p>
</li>
<li><p><strong>结构型模式：把类或对象结合在一起形成一个更大的结构。</strong></p>
</li>
<li><p><strong>行为型模式：类和对象如何交互，及划分责任和算法。</strong></p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/fdae8d21bb819edf30d14d8d8fb371d2.jpeg" alt="preview"></p>
<h2 id="一、设计模式的六大原则"><a href="#一、设计模式的六大原则" class="headerlink" title="一、设计模式的六大原则"></a>一、设计模式的六大原则</h2><p><strong>1、开闭原则（Open Close Principle）</strong></p>
<p>开闭原则的意思是：<strong>对扩展开放，对修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p>
<p><strong>2、里氏代换原则（Liskov Substitution Principle）</strong></p>
<p>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p>
<p><strong>3、依赖倒转原则（Dependence Inversion Principle）</strong></p>
<p>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</p>
<p><strong>4、接口隔离原则（Interface Segregation Principle）</strong></p>
<p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p>
<p><strong>5、迪米特法则，又称最少知道原则（Demeter Principle）</strong></p>
<p>最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p>
<p><strong>6、合成复用原则（Composite Reuse Principle）</strong></p>
<p>合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。</p>
<h2 id="二、创建型模式"><a href="#二、创建型模式" class="headerlink" title="二、创建型模式"></a>二、创建型模式</h2><p><strong>谈谈你对创建型模式的理解</strong></p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-0DejDU8a-1663068327816)(C:\Users\xhd\AppData\Roaming\Typora\typora-user-images\image-20220912161425121.png)]</p>
<h3 id="1-单例设计模式："><a href="#1-单例设计模式：" class="headerlink" title="1.单例设计模式："></a><strong>1.单例设计模式：</strong></h3><p><strong>一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫做单例设计模式</strong></p>
<p>单例模式是创建对象的一种特殊方式，程序从始至终都只创建一个对象叫单例</p>
<h4 id="1-1饿汉式单例"><a href="#1-1饿汉式单例" class="headerlink" title="1.1饿汉式单例"></a>1.1饿汉式单例</h4><p>饿汉式的实现方式比较简单。在类加载的时候，instance 静态实例就已经创建并初始化好了，所以，instance 实例的创建过程是线程安全的。不过，这样的实现方式不支持延迟加载（在真正用到 的时候，再创建实例）。</p>
<p>缺点：因为不支持延迟加载，如果实例占用资源多（比如占用内存多）或初始化耗时长（比如需要加载各种配置文件），提前初始化实例是一种浪费资源的行为。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="comment">//1、 饿汉式单例模式，  在类加载时创建一个对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 构造器私有化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Student</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3 提供返回类对象的静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Student <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(student !=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> student;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-2懒汉式单例"><a href="#1-2懒汉式单例" class="headerlink" title="1.2懒汉式单例"></a>1.2懒汉式单例</h4><p>在真正需要使用对象的时候才会去创建该对象；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lazy_Man</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lazy_Man lazyMan=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Lazy_Man</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Lazy_Man <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lazyMan==<span class="literal">null</span>)&#123;</span><br><span class="line">            lazyMan =<span class="keyword">new</span> <span class="title class_">Lazy_Man</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazyMan;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3双重检测锁"><a href="#1-3双重检测锁" class="headerlink" title="1.3双重检测锁"></a>1.3双重检测锁</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lazy_Man2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Lazy_Man2 lazyMan=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Lazy_Man2</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Lazy_Man2 <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Lazy_Man2.class)&#123;</span><br><span class="line">            <span class="keyword">if</span> (lazyMan==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//1.分配内存空间2．执行构造方法，实例化对象3.把这个对象赋值给这个空间</span></span><br><span class="line">                <span class="comment">//如果不加volatile会执行重排序13 2</span></span><br><span class="line">                lazyMan =<span class="keyword">new</span> <span class="title class_">Lazy_Man2</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazyMan;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-说说你在哪些框架中看到了单例的设计"><a href="#2-说说你在哪些框架中看到了单例的设计" class="headerlink" title="2.说说你在哪些框架中看到了单例的设计"></a>2.说说你在哪些框架中看到了单例的设计</h4><p>1.Spring中的Bean对象，默认是单例模式</p>
<p>⒉.相关的工厂对象都是单例，比如:MyBatis中的SqlSessionFactory，Spring中的BeanFactory.</p>
<p>3.保存相关配置信息的都是单例，比如:MyBatis中的Configuration对象，SpringBoot中的各个XXAutoConfiguration对象等</p>
<p>4.应用程序的日志应用，一般都会通过单例来实现</p>
<p>5.数据库连接池的设计也是单例模式</p>
<h3 id="2-工厂模式"><a href="#2-工厂模式" class="headerlink" title="2.工厂模式"></a>2.工厂模式</h3><p>创建对象的过程不再由当前类实例化，而是由工厂类完成，在工厂类中只需要告知对象类型即可。工厂模式中必须依赖接口</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-avQDvOtL-1663068327816)(C:\Users\xhd\AppData\Roaming\Typora\typora-user-images\image-20220911201734189.png)]</p>
<h4 id="2-1简单工厂模式"><a href="#2-1简单工厂模式" class="headerlink" title="2.1简单工厂模式"></a>2.1简单工厂模式</h4><h4 id="2-2工厂方法模式"><a href="#2-2工厂方法模式" class="headerlink" title="2.2工厂方法模式"></a>2.2工厂方法模式</h4><p> 工厂方法是针对每一种产品提供一个工厂类。通过不同的工厂实例来创建不同的产品实例。在同一等级结构中，<strong>支持增加任意产品</strong>。</p>
<p><strong>总而言之：一个接口被多实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个接口:</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建实现接口的实体类</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Inside Rectangle::draw() method.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Inside Square::draw() method.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建一个工厂，生成基于给定信息的实体类的对象。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShapeFactory</span> &#123;</span><br><span class="line">    <span class="comment">//创建一个工厂，生成基于给定信息的实体类的对象。</span></span><br><span class="line">    <span class="comment">//使用 getShape 方法获取形状类型的对象</span></span><br><span class="line">    <span class="keyword">public</span> Shape <span class="title function_">getShape</span><span class="params">(String shapeType)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(shapeType == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">&quot;CIRCLE&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">&quot;RECTANGLE&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">&quot;SQUARE&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Square</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用该工厂，通过传递类型信息来获取实体类的对象。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactoryPatternDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ShapeFactory shapeFactory=<span class="keyword">new</span> <span class="title class_">ShapeFactory</span>();</span><br><span class="line">        <span class="comment">//获取 Circle 的对象，并调用它的 draw 方法</span></span><br><span class="line">        <span class="type">Shape</span> <span class="variable">shape1</span> <span class="operator">=</span> shapeFactory.getShape(<span class="string">&quot;CIRCLE&quot;</span>);</span><br><span class="line">        <span class="comment">//调用 Circle 的 draw 方法</span></span><br><span class="line">        shape1.draw();</span><br><span class="line">        <span class="comment">//获取 Rectangle 的对象，并调用它的 draw 方法</span></span><br><span class="line">        <span class="type">Shape</span> <span class="variable">shape2</span> <span class="operator">=</span> shapeFactory.getShape(<span class="string">&quot;RECTANGLE&quot;</span>);</span><br><span class="line">        <span class="comment">//调用 Rectangle 的 draw 方法</span></span><br><span class="line">        shape2.draw();</span><br><span class="line">        <span class="comment">//获取 Square 的对象，并调用它的 draw 方法</span></span><br><span class="line">        <span class="type">Shape</span> <span class="variable">shape3</span> <span class="operator">=</span> shapeFactory.getShape(<span class="string">&quot;SQUARE&quot;</span>);</span><br><span class="line">        <span class="comment">//调用 Square 的 draw 方法</span></span><br><span class="line">        shape3.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-抽象工厂模式"><a href="#3-抽象工厂模式" class="headerlink" title="3.抽象工厂模式"></a>3.抽象工厂模式</h3><p>抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//为 Color 和 Shape 对象创建抽象类来获取工厂。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> Color <span class="title function_">getColor</span><span class="params">(String color)</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> Shape <span class="title function_">getShape</span><span class="params">(String shape)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建扩展了 AbstractFactory 的工厂类，基于给定的信息生成实体类的对象。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ColorFactory</span> <span class="keyword">extends</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Shape <span class="title function_">getShape</span><span class="params">(String shapeType)</span>&#123; <span class="keyword">return</span> <span class="literal">null</span>;&#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Color <span class="title function_">getColor</span><span class="params">(String color)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(color == <span class="literal">null</span>)&#123; <span class="keyword">return</span> <span class="literal">null</span>;&#125;        </span><br><span class="line">      <span class="keyword">if</span>(color.equalsIgnoreCase(<span class="string">&quot;RED&quot;</span>))&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Red</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(color.equalsIgnoreCase(<span class="string">&quot;GREEN&quot;</span>))&#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Green</span>();&#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建一个工厂创造器/生成器类，通过传递形状或颜色信息来获取工厂。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactoryProducer</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> AbstractFactory <span class="title function_">getFactory</span><span class="params">(String choice)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(choice.equalsIgnoreCase(<span class="string">&quot;SHAPE&quot;</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ShapeFactory</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(choice.equalsIgnoreCase(<span class="string">&quot;COLOR&quot;</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ColorFactory</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用 FactoryProducer 来获取 AbstractFactory，通过传递类型信息来获取实体类的对象。</span></span><br><span class="line"><span class="comment">//获取颜色工厂</span></span><br><span class="line">      <span class="type">AbstractFactory</span> <span class="variable">colorFactory</span> <span class="operator">=</span> FactoryProducer.getFactory(<span class="string">&quot;COLOR&quot;</span>);</span><br><span class="line">      <span class="comment">//获取颜色为 Red 的对象</span></span><br><span class="line">      <span class="type">Color</span> <span class="variable">color1</span> <span class="operator">=</span> colorFactory.getColor(<span class="string">&quot;RED&quot;</span>);</span><br><span class="line">      <span class="comment">//调用 Red 的 fill 方法</span></span><br><span class="line">      color1.fill();</span><br><span class="line">      <span class="comment">//获取颜色为 Green 的对象</span></span><br><span class="line">      <span class="type">Color</span> <span class="variable">color2</span> <span class="operator">=</span> colorFactory.getColor(<span class="string">&quot;GREEN&quot;</span>);</span><br><span class="line">      <span class="comment">//调用 Green 的 fill 方法</span></span><br><span class="line">      color2.fill();</span><br></pre></td></tr></table></figure>



<h4 id="总结：对于简单工厂，工厂方法模式和抽象工厂的区别和用途"><a href="#总结：对于简单工厂，工厂方法模式和抽象工厂的区别和用途" class="headerlink" title="总结：对于简单工厂，工厂方法模式和抽象工厂的区别和用途"></a>总结：对于简单工厂，工厂方法模式和抽象工厂的区别和用途</h4><p>小结：</p>
<p>★工厂模式中，重要的是工厂类，而不是产品类。产品类可以是多种形式，多层继承或者是单个类都是可以的。但要明确的，工厂模式的接口只会返回一种类型的实例，这是在设计产品类的时候需要注意的，最好是有父类或者共同实现的接口。</p>
<p>★使用工厂模式，返回的实例一定是工厂创建的，而不是从其他对象中获取的。</p>
<p>★工厂模式返回的实例可以不是新创建的，返回由工厂创建好的实例也是可以的。</p>
<p>区别：</p>
<p>1、对于简单工厂，用于生产同一结构中的任意产品，对于新增产品不适用。</p>
<p>2、对于工厂方法，在简单工厂的基础上，生产同一等级结构中笃定产品，可以支持新增产品。</p>
<p>3、抽象工厂，用于生产不同种类（品牌）的相同类型（迷你，SUV），对于新增品牌可以，不支持新增类型</p>
<h3 id="4-建造者模式"><a href="#4-建造者模式" class="headerlink" title="4.建造者模式"></a>4.建造者模式</h3><p>用来解决复杂对象创建的一种设计模式</p>
<p>建造者模式和工厂模式的区别：</p>
<ul>
<li>建造者模式更加注重方法的调用顺序，工厂模式注重于创建对象。</li>
<li>创建对象的力度不同，建造者模式创建复杂的对象，由各种复杂的部件组成，工厂模式创建出来的都一样。</li>
<li>关注点不一样，工厂模式只需要把对象创建出来就行了，而建造者模式不仅要创建出这个对象，还要知道这个对象由哪些部分组成。</li>
<li>建造者模式根据建造过程中的顺序不一样，最终的对象部件组成也不一样。</li>
</ul>
<h3 id="5-原型模式"><a href="#5-原型模式" class="headerlink" title="5.原型模式"></a>5.原型模式</h3><p><strong>批量对象的创建</strong></p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-bjq7WTPC-1663068327816)(C:\Users\xhd\AppData\Roaming\Typora\typora-user-images\image-20220912155839207.png)]</p>
<h4 id="5-1浅克隆"><a href="#5-1浅克隆" class="headerlink" title="5.1浅克隆"></a>5.1浅克隆</h4><p>​        被复制对象的所有变是都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。换言之，浅复制仅仅复制所考虑的对象，而不复制它所引用的对象。0bject类提供的方法clone=只是拷贝本对象=，=其对象内部的数组、引用对象等都不拷贝=，还是指向原生对象的内部元素地址.<br>被克隆的对象必须Cloneable,Serializable这两个接口;</p>
<p><strong>浅克隆的问题:虽然产生了两个完全不同的对象，但是被复制的对象的所有变是都含有与原来的对象相同的值，而所有的对其他对象的引用都仍然指向原来的对象。</strong></p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-4ebxiWrR-1663068327817)(C:\Users\xhd\AppData\Roaming\Typora\typora-user-images\image-20220912160030557.png)]</p>
<h4 id="5-2深克隆"><a href="#5-2深克隆" class="headerlink" title="5.2深克隆"></a>5.2深克隆</h4><p>​        被复制对象的所有变量都含有与原来的对象相同的值，除去那些引用其他对象的变量。那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。换言之，深复制把要复制的对象所引用的对象都复制了一遍。</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-t4xTggHP-1663068327817)(C:\Users\xhd\AppData\Roaming\Typora\typora-user-images\image-20220912162324503.png)]</p>
<h2 id="三、结构型模式"><a href="#三、结构型模式" class="headerlink" title="三、结构型模式"></a>三、结构型模式</h2><h3 id="1-代理模式"><a href="#1-代理模式" class="headerlink" title="1.代理模式"></a>1.代理模式</h3><h4 id="1-1代理模式的作用"><a href="#1-1代理模式的作用" class="headerlink" title="1.1代理模式的作用"></a>1.1代理模式的作用</h4><p>​        代理模式的作用是通过代理对象来增强目标对象的功能，利用AOP的切面思想。</p>
<h4 id="1-2代理模式的实现方式"><a href="#1-2代理模式的实现方式" class="headerlink" title="1.2代理模式的实现方式"></a>1.2代理模式的实现方式</h4><p>代理模式的实现方式有三种:静态代理，动态代理(JDK动态代理和CGLIB动态代理)</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-N0AbMJS6-1663068327817)(C:\Users\xhd\AppData\Roaming\Typora\typora-user-images\image-20220912162945257.png)]</p>
<h5 id="1-2-1静态代理"><a href="#1-2-1静态代理" class="headerlink" title="1.2.1静态代理"></a>1.2.1静态代理</h5><p><strong>静态代理需要代理类与目标类有一样的继承父类和实现接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteUser</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DbUser</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;添加用户操作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteUser</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;删除用户操作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticProxyUser</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> DbUser target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StaticProxyUser</span><span class="params">(DbUser dbUser)</span> &#123;</span><br><span class="line">        target = dbUser;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;添加前的操作&quot;</span>);</span><br><span class="line">        target.addUser();</span><br><span class="line">        System.out.println(<span class="string">&quot;添加后的操作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteUser</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;删除前的操作&quot;</span>);</span><br><span class="line">        target.deleteUser();</span><br><span class="line">        System.out.println(<span class="string">&quot;删除后的操作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">demo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">StaticProxyUser</span> <span class="variable">staticProxyUser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticProxyUser</span>(<span class="keyword">new</span> <span class="title class_">DbUser</span>());</span><br><span class="line">        staticProxyUser.addUser();</span><br><span class="line">        staticProxyUser.deleteUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态代理总结:</p>
<p>1.可以做到在不修改目标对象的功能前提下,对目标功能扩展.<br>2.缺点:<br>因为代理对象需要与目标对象实现一样的接口,所以会有很多代理类,类太多.同时,一旦接口增加方法,目标对象与代理对象都要维护.</p>
<h5 id="1-2-2-JDK动态代理"><a href="#1-2-2-JDK动态代理" class="headerlink" title="1.2.2 JDK动态代理"></a>1.2.2 JDK动态代理</h5><p>动态代理不用实现目标类的接口，不会出现大量代理类的现象，一般情况下创建一个代理类就可以了。<br>动态代理对象的生成,是利用JDK的API,动态的在内存中构建代理对象(需要我们指定创建代理对象/目标对象实现的接口的类型)<br>动态代理也叫做:JDK代理,接口代理<br>动态代理需要使用newProxyInstance方法，该方法结构为static Object newProxyInstance(ClassLoader loader， Class&lt;?&gt;] interfaces,InvocationHandler h )，可以看到该方法需要三个参数<br>参数1：ClassLoader 需要一个类加载器，Java中常用的类加载器有三种类型<br>启动类加载器(Bootstrap ClassLoader):</p>
<p>　　　　这个类加载器负责将\lib目录下的类库加载到虚拟机内存中,用来加载java的核心库,此类加载器并不继承于java.lang.ClassLoader,不能被java程序直接调用,代码是使用C++编写的.是虚拟机自身的一部分.</p>
<p>　　　扩展类加载器(Extendsion ClassLoader):<br>　　　　这个类加载器负责加载\lib\ext目录下的类库,用来加载java的扩展库,开发者可以直接使用这个类加载器.</p>
<p>　　　应用程序类加载器(Application ClassLoader):</p>
<p>　　　　这个类加载器负责加载用户类路径(CLASSPATH)下的类库,一般我们编写的java类都是由这个类加载器加载,这个类加载器是CLassLoader中的getSystemClassLoader()方法的返回值,所以也称为系统类加载器.一般情况下这就是系统默认的类加载器.</p>
<p>　　除此之外,我们还可以加入自己定义的类加载器,以满足特殊的需求,需要继承java.lang.ClassLoader类.<br>　　参数2：Class &lt;?&gt;[] interfaces,:目标对象实现的接口的类型,使用泛型方式确认类型<br>　　参数3：InvocationHandler h:事件处理,执行目标对象的方法时,会触发事件处理器的方法,会把当前执行目标对象的方法作为参数传入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">delUser</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;添加用户&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;更新用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delUser</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;删除用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//   代理类：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProxyFactory</span><span class="params">(Object object)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.target=object;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getProxyInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(ProxyFactory.class.getClassLoader(),<span class="comment">//类加载器</span></span><br><span class="line">                                      target.getClass().getInterfaces(), <span class="comment">//目标对象实现的相关接口</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;<span class="comment">//代理对象的回调方法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;开始事务2&quot;</span>);</span><br><span class="line">                <span class="type">Object</span> <span class="variable">invoke</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">                System.out.println(<span class="string">&quot;提交事务2&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> invoke;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mtytest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        UserService userService=<span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">instance</span> <span class="operator">=</span> (UserService) <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>(userService).getProxyInstance();</span><br><span class="line">        instance.addUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>笔试题</strong>:写一个 ArrayList 的动态代理类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyTest</span> &#123;</span><br><span class="line">    <span class="comment">//写一个 ArrayList 的动态代理类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;String&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; proxyInstance = (List&lt;String&gt;) Proxy.newProxyInstance(list.getClass().getClassLoader(), list.getClass().getInterfaces(), <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                <span class="type">Object</span> <span class="variable">invoke</span> <span class="operator">=</span> method.invoke(list, args);</span><br><span class="line">                <span class="keyword">return</span> invoke;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        proxyInstance.add(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-2-3CGLIB代理"><a href="#1-2-3CGLIB代理" class="headerlink" title="1.2.3CGLIB代理"></a>1.2.3CGLIB代理</h5><p>Cglib代理,也叫作子类代理,它是在内存中构建一个子类对象从而实现对目标对象功能的扩展.</p>
<p>DK的动态代理有一个限制,就是使用动态代理的对象必须实现一个或多个接口,如果想代理没有实现接口的类,就可以使用Cglib实现.<br>Cglib是一个强大的高性能的代码生成包,它可以在运行期扩展java类与实现java接口.它广泛的被许多AOP的框架使用,例如Spring AOP和synaop,为他们提供方法的interception(拦截)<br>Cglib包的底层是通过使用一个小而块的字节码处理框架ASM来转换字节码并生成新的类.不鼓励直接使用ASM,因为它要求你必须对JVM内部结构包括class文件的格式和指令集都很熟悉.<br>Cglib子类代理实现方法:<br>1.需要引入cglib的jar文件,但是Spring的核心包中已经包括了Cglib功能,所以直接引入pring-core-3.2.5.jar即可.<br>2.引入功能包后,就可以在内存中动态构建子类<br>3.代理的类不能为final,否则报错<br>4.目标对象的方法如果为final/static,那么就不会被拦截,即不会执行目标对象额外的业务方法.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接口和目标类同上</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanFactory</span> &#123;</span><br><span class="line">    <span class="comment">//cglib代理</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserService <span class="title function_">createUserService</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//目标类</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 代理类</span></span><br><span class="line"><span class="comment">         * 回掉函数中的intercept同jdk动态代理的invoke方法</span></span><br><span class="line"><span class="comment">         * 4个参数，前三个同jdk动态代理的参数</span></span><br><span class="line"><span class="comment">         * 第四个参数：methodProxy是目标类的方法的代理</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//1.1核心类</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">//1.2确定父类</span></span><br><span class="line">        enhancer.setSuperclass(UserService.class);</span><br><span class="line">        <span class="comment">//1.3设置回掉函数</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">MethodInterceptor</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;执行前&quot;</span>);</span><br><span class="line">                <span class="type">Object</span> <span class="variable">invoke</span> <span class="operator">=</span> method.invoke(userService, objects);</span><br><span class="line">                System.out.println(<span class="string">&quot;执行后&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> invoke;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService1</span> <span class="operator">=</span> (UserService) enhancer.create();</span><br><span class="line">       <span class="keyword">return</span> userService1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>面试题一：JDK动态代理和CGLIB动态代理区别？</strong></p>
<p>① JDK 动态代理本质上是实现了<strong>被代理对象的接口</strong>，而 CGLib 本质上是<strong>继承了被代理对象</strong>，覆盖其中的方法。<br>② JDK 动态代理只能对实现了接口的类生成代理，CGLib 则没有这个限制。但是 CGLib 因为使用继承实现，所以 CGLib 所以无法对 final 类、private 方法和 static方法进行代理。<br>③ JDK 动态代理是 JDK 里自带的，CGLib 动态代理需要引入第三方的 jar 包。<br>④ 在调用代理方法上，JDK动态代理是通过反射机制调用，CGLib 是通过 FastClass 机制直接调用。（看过一篇文章，介绍说 FastClass 简单的理解，就是使用一个 index 下标作为入参，可以直接定位到要调用的方法直接，并进行调用）</p>
<p>在性能上，JDK1.7 之前，由于使用了 FastClass 机制，CGLib 在执行效率上比 JDK 快，但是随着 JDK 动态代理的不断优化，从 JDK 1.7 开始，JDK 动态代理已经明显比 CGLib 更快了。</p>
<h3 id="2-适配器模式"><a href="#2-适配器模式" class="headerlink" title="2.适配器模式"></a>2.适配器模式</h3><p>适配器模式的作用是把两个不兼容的类/对象/接口通过适配器能够连接起来工作。</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-S1YIzeAx-1663068327818)(C:\Users\xhd\AppData\Roaming\Typora\typora-user-images\image-20220912192231507.png)]</p>
<h4 id="2-1类适配器模式"><a href="#2-1类适配器模式" class="headerlink" title="2.1类适配器模式"></a>2.1类适配器模式</h4><p> 从下面的结构图可以看出，Adaptee类并没有method2()方法，而客户端则期待这个方法。为使客户端能够使用Adaptee类，我们把Adaptee与Target衔接起来。Adapter与Adaptee是继承关系，这决定了这是一个类适配器模式</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/cdd22b8fc09c022a6be0c6002bc267ef.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//源：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adaptee</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;老的方法实现&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//目标：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//适配器：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adapter</span> <span class="keyword">extends</span> <span class="title class_">Adaptee</span> <span class="keyword">implements</span> <span class="title class_">Target</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Adapter</span><span class="params">(Adaptee adaptee)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.adaptee = adaptee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method2&quot;</span> + <span class="string">&quot;新的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-2对象适配器模式"><a href="#2-2对象适配器模式" class="headerlink" title="2.2对象适配器模式"></a>2.2对象适配器模式</h4><p>从下面的结构图可以看出，Adaptee类并没有method2()方法，而客户端则期待这个方法。与类适配器模式一样，为使客户端能够使用Adaptee类，我们把Adaptee与Target衔接起来。但这里我们不继承Adaptee，而是把Adaptee封装进Adapter里。这里Adaptee与Adapter是组合关系。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/c1b4cac85f07d05dc3a8a7ea19a9ff8f.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Target和Adaptee和上面的类适配器一样</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adapter1</span> <span class="keyword">implements</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Adapter1</span><span class="params">(Adaptee adaptee)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.adaptee = adaptee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        adaptee.method1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method2&quot;</span> + <span class="string">&quot;新的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>类适配器与对象适配器的区别</strong><br> 类适配器使用的是继承的方式，直接继承了Adaptee，所以无法对Adaptee的子类进行适配。<br> 对象适配器使用的是组合的方式，·所以Adaptee及其子孙类都可以被适配。另外，对象适配器对于增加一些新行为非常方便，而且新增加的行为同时适用于所有的源。<br> 基于组合/聚合优于继承的原则，使用对象适配器是更好的选择。</p>
<h3 id="3-装饰者模式"><a href="#3-装饰者模式" class="headerlink" title="3.装饰者模式"></a>3.装饰者模式</h3><h4 id="3-1装饰者模式的作用"><a href="#3-1装饰者模式的作用" class="headerlink" title="3.1装饰者模式的作用"></a>3.1装饰者模式的作用</h4><p>允许向一个现有的对象添加新的功能，同时又不改变其结构</p>
<p>装饰者模式又称为包装模式(Wrapper),作用是用来动态的为一个对象增加新的功能。装饰模式是一种用于代替继承的技术，无须通过继承增加子类就能扩展对象的新功能。使用对象的关联关系代替继承关系，更加灵活，同时避免类型体系的快速膨胀。</p>
<h2 id="四、行为型模式"><a href="#四、行为型模式" class="headerlink" title="四、行为型模式"></a>四、行为型模式</h2><h4 id="1-观察者模式"><a href="#1-观察者模式" class="headerlink" title="1.观察者模式"></a>1.观察者模式</h4><h5 id="1-1观察者模式的作用"><a href="#1-1观察者模式的作用" class="headerlink" title="1.1观察者模式的作用"></a>1.1观察者模式的作用</h5><p>建立对象与对象之间的依赖关系，一个对象发生改变时，会自动通知其他对象。这个场景中，发生改变的对象被称为观察目标，被通知的对象称为观察者。一个观察目标可以有多个观察者，而这些观察者之间可以没有联系，可以根据需要增加或删除观察者。</p>
<p>public void method2() {<br>        System.out.println(“method2” + “新的方法”);<br>    }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">**类适配器与对象适配器的区别**</span><br><span class="line"> 类适配器使用的是继承的方式，直接继承了Adaptee，所以无法对Adaptee的子类进行适配。</span><br><span class="line"> 对象适配器使用的是组合的方式，·所以Adaptee及其子孙类都可以被适配。另外，对象适配器对于增加一些新行为非常方便，而且新增加的行为同时适用于所有的源。</span><br><span class="line"> 基于组合/聚合优于继承的原则，使用对象适配器是更好的选择。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 3.装饰者模式</span><br><span class="line"></span><br><span class="line">#### 3.1装饰者模式的作用</span><br><span class="line"></span><br><span class="line">允许向一个现有的对象添加新的功能，同时又不改变其结构</span><br><span class="line"></span><br><span class="line">装饰者模式又称为包装模式(Wrapper),作用是用来动态的为一个对象增加新的功能。装饰模式是一种用于代替继承的技术，无须通过继承增加子类就能扩展对象的新功能。使用对象的关联关系代替继承关系，更加灵活，同时避免类型体系的快速膨胀。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 四、行为型模式</span><br><span class="line"></span><br><span class="line">#### 1.观察者模式</span><br><span class="line"></span><br><span class="line">##### 1.1观察者模式的作用</span><br><span class="line"></span><br><span class="line">建立对象与对象之间的依赖关系，一个对象发生改变时，会自动通知其他对象。这个场景中，发生改变的对象被称为观察目标，被通知的对象称为观察者。一个观察目标可以有多个观察者，而这些观察者之间可以没有联系，可以根据需要增加或删除观察者。</span><br><span class="line"></span><br><span class="line">[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-27vFqzMv-1663068327820)(C:\Users\xhd\AppData\Roaming\Typora\typora-user-images\image-20220912212546248.png)]</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Java</tag>
        <tag>面试</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
</search>
